  核心逻辑：分别获取用户和电脑的最长连子长度
           若电脑最大连子长度不小于用户，或者最大连子长度小于用户但是用户最大连子长度没到3时，可以直接返回电脑获取到最大连子长度的落子位置。（攻）
           否则的话，对用户进行封堵（三连子的情况）。（守）

  除了核心逻辑，还有一些对特殊情况的处理，在判断核心逻辑前，进行了几个判断（弥补核心逻辑的不足）：
         1：若电脑有四连子，只有一端被堵，则判断直接下另一端可获胜。
         2：若电脑有三连子或四连子被用户封堵了，则更新电脑最长连子长度。
         3：若电脑下一步落子无法获胜，则判断用户是否存在"●●+●●"（直线）的情况，存在则封堵。
         4：若电脑最长连子长度小于3，则若用户存在"●●+●"的情况，则封堵。
      进行上述判断后有需要的话再进入核心逻辑处理。

  我的程序没有考虑对用户"●●+●●"（成45°或90°或135°）的判断，如果采用穷举法，在核心逻辑判断前，加入：
              若电脑最长连子长度小于3,则根据用户最新落子位置用穷举法（共96种可能存在的情况）判断"●●+●●"（成45°或90°或135°）的情况是否存在，
            若存在则封堵即可，因为要判断的情形（96种）太多，所以我没做。
  除了"●●+●●"（成45°或90°或135°）这种情况，经过测试，其他还是比较智能的。
